### 串列單子與陣列歸納
串列單子的實例定義
```haskell
instance Monad [] where
  return x = [x]
  x >>= f = concat $ fmap f x
```
把每次返回多個結果的計算連接起來，合成一個返回所有可能結果的計算
```haskell
Prelude> :{ -- GHCi 多行排版
Prelude| do
Prelude|    x <- [1, 2, 3]
Prelude|    y <- [4, 5, 6]
Prelude|   return $ x * y
Prelude| :}
[4, 5, 6, 8, 10, 12, 12, 15, 18]
```
串列歸納 (list comprehension) <br>
出自串列單子的 do 語法 <br>
上面的式子改寫：
```haskell
[x * y | x <- [1, 2, 3], y <- [4, 5, 6]]
```
比 do 方便的是，| 後面可以連接返回 Bool 的判斷條件 <br>
可用來過濾符合條件的元素 <br>
例子：求出長寬合小於 10 的所有矩陣面積：
```haskell
[x * y | x <- [1..10], y <- [x..10, x + y < 10]]

-- 對應 do

do 
  x <- [1..10]
  y <- [x..10]
  if x + y < 10 
    then return $ x * y
    else []
```
#### 八皇后問題
根據擺放皇后的規則，即同一條橫行、縱行、斜行上不能出現兩個皇后
* 寫一個函數“判斷座標串列對應的情況”是否符合擺放規則 -> 判斷串列中任意兩個皇后不衝突，要計算很多對皇后組合的情形
* 考慮逐步建構符合要求的串列：每一步在新的一行新增一個皇后，可能會產生若干種方案，然後把所有可能的方案“分別”繼續新增下去 -> 動態規劃

情境：在給定前 m 行的擺放方案後，如何得到所有可能的 m+1 行擺放方案？ <br>
這裡需要從 8 個可能的橫坐標中，找出和之前 m 行的皇后都不衝突的位置

* haskell 中函數在串列前面插入新的座標，比在尾末插入快很多，所以從第 8 行開始，一行一行往上新增 
<br>
問題：如何判斷新的座標和之前 m 行的擺放是否衝突
<br>

* safe 函數可以判斷新的座標加到串列最前面之後，和後面每一行的棋子是否衝突 (n 初始值為 1) 
* 每次遞迴時，n 加 1 表示要判斷的行數向下移動了 1 行，直到把之前的方案都判斷完畢，任一步失敗，都會 return false ，代表新的座標 x 和之前的擺放方案衝突

```haskell
safe :: Int -> [Int] -> Int -> Bool
-- 第一個參數：新的橫座標
-- 第二個參數：前 m 行的擺放方案
-- 第三個參數：遞迴時的迴圈變數，用來表示判斷到了前 m 行的第幾行

-- 第一次擺放，任意擺都行
safe _ [] _ = True
-- 接下來從前 m 行的最上面一行開始判斷，即 n 從 1 開始
safe x (x1:xs) n = 
  -- 是否在同一列？
  x /= x1
  -- 是否在同斜線？
  && x /= x1 + n && x /= x1 - n
  -- 和前 m-1 行的皇后一起是否安全？
  && safe x xs (n+1)
```

