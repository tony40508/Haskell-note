### 串列單子與陣列歸納
串列單子的實例定義
```haskell
instance Monad [] where
  return x = [x]
  x >>= f = concat $ fmap f x
```
把每次返回多個結果的計算連接起來，合成一個返回所有可能結果的計算
```haskell
Prelude> :{ -- GHCi 多行排版
Prelude| do
Prelude|    x <- [1, 2, 3]
Prelude|    y <- [4, 5, 6]
Prelude|   return $ x * y
Prelude| :}
[4, 5, 6, 8, 10, 12, 12, 15, 18]
```
串列歸納 (list comprehension) <br>
出自串列單子的 do 語法 <br>
上面的式子改寫：
```haskell
[x * y | x <- [1, 2, 3], y <- [4, 5, 6]]
```
比 do 方便的是，| 後面可以連接返回 Bool 的判斷條件 <br>
可用來過濾符合條件的元素 <br>
例子：求出長寬合小於 10 的所有矩陣面積：
```haskell
[x * y | x <- [1..10], y <- [x..10, x + y < 10]]

-- 對應 do

do 
  x <- [1..10]
  y <- [x..10]
  if x + y < 10 
    then return $ x * y
    else []
```
#### 八皇后問題
根據擺放皇后的規則，即同一條橫行、縱行、斜行上不能出現兩個皇后
* 寫一個函數“判斷座標串列對應的情況”是否符合擺放規則 -> 判斷串列中任意兩個皇后不衝突，要計算很多對皇后組合的情形
* 考慮逐步建構符合要求的串列：每一步在新的一行新增一個皇后，可能會產生若干種方案，然後把所有可能的方案“分別”繼續新增下去 -> 動態規劃
